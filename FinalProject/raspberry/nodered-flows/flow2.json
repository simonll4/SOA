[
    {
        "id": "5a4b47febf53ae59",
        "type": "tab",
        "label": "Flow 2",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "f8bcc2348cc2da98",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e095f4b5827799a6",
        "type": "subflow",
        "name": "load_process (2)",
        "info": "Subflujo profesional para simulación de nivel, volumen, caudal y ETA con corrección de altura desde sensor.",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 60,
                "wires": [
                    {
                        "id": "a4047899c62da3e8"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 940,
                "y": 200,
                "wires": [
                    {
                        "id": "3f30980c4238f848",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "a4047899c62da3e8",
        "type": "exec",
        "z": "e095f4b5827799a6",
        "command": "/home/simonll4/python/.venv/bin/python /home/simonll4/python/main.py",
        "addpay": "payload",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Ejecutar sensor HC-SR04",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "0f314632432fd961"
            ],
            [],
            []
        ]
    },
    {
        "id": "712635c85256f520",
        "type": "debug",
        "z": "e095f4b5827799a6",
        "name": "Resultado Final",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 380,
        "wires": []
    },
    {
        "id": "6cf0f8dd9a7322e0",
        "type": "function",
        "z": "e095f4b5827799a6",
        "name": "Calcular nivel, volumen, Q, ETA",
        "func": "// Retrieve container configuration\nconst container = global.get(\"container\");\nif (!container || !container.calibration_table || !container.height) {\n  node.error(\"Incomplete or missing container configuration\");\n  return null;\n}\n\nconst calibrationTable = container.calibration_table;\nconst maxHeight = container.height;\nconst maxVolume = calibrationTable[calibrationTable.length - 1].volume;\n\n// Get operation mode: 'load' (default) or 'discharge'\nconst operationMode = flow.get(\"operation_mode\") || \"load\";\n\n// Read or set reference height (distance from sensor to bottom of the container)\nlet sensorToBottom = flow.get(\"sensor_to_bottom\");\nconst distance = msg.payload.distance_cm;\nconst temperature = msg.payload.temperature;\nconst timestamp = Date.now();\n\nif (sensorToBottom === null || sensorToBottom === undefined) {\n  sensorToBottom = distance;\n  flow.set(\"sensor_to_bottom\", sensorToBottom);\n  node.warn(`Reference height saved: ${sensorToBottom} cm`);\n}\n\n// Calculate current liquid level\nlet level = sensorToBottom - distance;\nlet adjustedLevel = Math.max(0, Math.min(level, maxHeight)); // Clamp between 0 and container height\n\n// Linear interpolation for volume based on calibration table\nfunction interpolate(table, h) {\n  for (let i = 0; i < table.length - 1; i++) {\n    let a = table[i];\n    let b = table[i + 1];\n    if (h >= a.height && h <= b.height) {\n      let ratio = (h - a.height) / (b.height - a.height);\n      return a.volume + ratio * (b.volume - a.volume);\n    }\n  }\n  if (h <= table[0].height) return table[0].volume;\n  if (h >= table[table.length - 1].height)\n    return table[table.length - 1].volume;\n  return 0;\n}\n\n// Apply temperature compensation\nconst beta = 0.000214;\nconst referenceTemp = 20;\nconst rawVolume = interpolate(calibrationTable, adjustedLevel);\nlet adjustedVolume = rawVolume * (1 + beta * (temperature - referenceTemp));\nadjustedVolume = Math.max(0, Math.min(adjustedVolume, maxVolume)); // Clamp between 0 and max volume\n\n// Calculate flow rate and ETA\nconst previous = context.get(\"previous\") || {};\nconst deltaTime = (timestamp - (previous.timestamp || timestamp)) / 1000;\nconst deltaVolume = adjustedVolume - (previous.volume || adjustedVolume);\nconst flowRate = deltaTime > 0 ? deltaVolume / deltaTime : 0;\n\nlet ETA = 0;\nif (Math.abs(flowRate) > 0.001) {\n  if (operationMode === \"load\" && flowRate > 0) {\n    ETA = (maxVolume - adjustedVolume) / flowRate;\n  } else if (operationMode === \"discharge\" && flowRate < 0) {\n    ETA = adjustedVolume / Math.abs(flowRate);\n  }\n}\n\n// Save current state for next calculation\ncontext.set(\"previous\", { timestamp, volume: adjustedVolume });\n\n// Check completion conditions\nlet completionStatus = null;\nconst tolerance = 0.01 * maxVolume; // 1% tolerance for completion\n\nif (operationMode === \"load\") {\n  // For loading operation, check if container is full (within tolerance)\n  if (adjustedVolume >= maxVolume - tolerance) {\n    completionStatus = \"filled\";\n    node.log(\n      `Container filled (${adjustedVolume.toFixed(2)}L >= ${(\n        maxVolume - tolerance\n      ).toFixed(2)}L)`\n    );\n  }\n} else if (operationMode === \"discharge\") {\n  // For discharge operation, check if container is empty (within tolerance)\n  if (adjustedVolume <= tolerance) {\n    completionStatus = \"emptied\";\n    node.log(\n      `Container emptied (${adjustedVolume.toFixed(2)}L <= ${tolerance.toFixed(\n        2\n      )}L)`\n    );\n  }\n}\n\n// Output message\nmsg.payload = {\n  container_id: container.id,\n  level_cm: adjustedLevel.toFixed(2),\n  temperature_C: temperature,\n  volume_L: adjustedVolume.toFixed(2),\n  flow_rate_Lps: flowRate.toFixed(3),\n  ETA_seconds: ETA.toFixed(1),\n  timestamp: msg.payload.timestamp,\n  operation_mode: operationMode,\n};\n\n// Add flow control property\nmsg.flowControl = {\n  shouldTerminate: completionStatus !== null,\n  terminationReason: completionStatus,\n  terminationTime: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 230,
        "y": 280,
        "wires": [
            [
                "6cdb09570afa5d2f"
            ]
        ]
    },
    {
        "id": "0f314632432fd961",
        "type": "json",
        "z": "e095f4b5827799a6",
        "name": "Parsear JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 200,
        "y": 200,
        "wires": [
            [
                "6cf0f8dd9a7322e0"
            ]
        ]
    },
    {
        "id": "3f30980c4238f848",
        "type": "exec",
        "z": "e095f4b5827799a6",
        "command": "/home/simonll4/python/stop_sensor.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Terminar script del sensor",
        "x": 710,
        "y": 200,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "6cdb09570afa5d2f",
        "type": "switch",
        "z": "e095f4b5827799a6",
        "name": "¿Continuar o terminar?",
        "property": "flowControl.shouldTerminate",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 210,
        "y": 360,
        "wires": [
            [
                "3f30980c4238f848",
                "93c7b22fe1c70de3"
            ],
            [
                "712635c85256f520",
                "795c308dc73003c9"
            ]
        ]
    },
    {
        "id": "795c308dc73003c9",
        "type": "link out",
        "z": "e095f4b5827799a6",
        "name": "Continuar",
        "mode": "link",
        "links": [],
        "x": 655,
        "y": 340,
        "wires": []
    },
    {
        "id": "93c7b22fe1c70de3",
        "type": "link out",
        "z": "e095f4b5827799a6",
        "name": "Terminar",
        "mode": "link",
        "links": [],
        "x": 635,
        "y": 140,
        "wires": []
    },
    {
        "id": "e1e7350ba08a98b0",
        "type": "inject",
        "z": "5a4b47febf53ae59",
        "name": "Cargar JSON",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 130,
        "y": 140,
        "wires": [
            [
                "9f05f3e1f9a04cbd"
            ]
        ]
    },
    {
        "id": "9f05f3e1f9a04cbd",
        "type": "file in",
        "z": "5a4b47febf53ae59",
        "name": "Leer containers.json",
        "filename": "/home/simonll4/python/containers.json",
        "filenameType": "str",
        "format": "utf8",
        "sendError": true,
        "encoding": "none",
        "allProps": false,
        "x": 350,
        "y": 140,
        "wires": [
            [
                "c4d6d1438cb5374e"
            ]
        ]
    },
    {
        "id": "c4d6d1438cb5374e",
        "type": "json",
        "z": "5a4b47febf53ae59",
        "name": "Parsear JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 600,
        "y": 140,
        "wires": [
            [
                "42288f9db76f18fc"
            ]
        ]
    },
    {
        "id": "42288f9db76f18fc",
        "type": "function",
        "z": "5a4b47febf53ae59",
        "name": "Guardar en global y activar flujo",
        "func": "\nconst container = msg.payload[0];\nglobal.set(\"container\", container);\n\n// Payload vacío para activar otro flujo\nreturn { payload: msg.payload };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 140,
        "wires": [
            [
                "ca243dfdd9aa51de"
            ]
        ]
    },
    {
        "id": "ca243dfdd9aa51de",
        "type": "link out",
        "z": "5a4b47febf53ae59",
        "name": "Activar flujo sensor",
        "mode": "link",
        "links": [
            "ae2632dff5e8c4a0"
        ],
        "x": 1105,
        "y": 140,
        "wires": []
    },
    {
        "id": "ae2632dff5e8c4a0",
        "type": "link in",
        "z": "5a4b47febf53ae59",
        "name": "Sensor - Entrada activación",
        "links": [
            "ca243dfdd9aa51de"
        ],
        "x": 45,
        "y": 320,
        "wires": [
            [
                "332ad329e2cdb83e"
            ]
        ]
    },
    {
        "id": "332ad329e2cdb83e",
        "type": "exec",
        "z": "5a4b47febf53ae59",
        "command": "/home/simonll4/python/.venv/bin/python /home/simonll4/python/main.py",
        "addpay": false,
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Ejecutar sensor HC-SR04",
        "x": 250,
        "y": 320,
        "wires": [
            [
                "31e733e431eb7319"
            ],
            [],
            []
        ]
    },
    {
        "id": "31e733e431eb7319",
        "type": "debug",
        "z": "5a4b47febf53ae59",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 220,
        "wires": []
    },
    {
        "id": "f92301aee312b47c",
        "type": "exec",
        "z": "5a4b47febf53ae59",
        "command": "/home/simonll4/python/.venv/bin/python /home/simonll4/python/main.py",
        "addpay": "payload",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Ejecutar sensor HC-SR04",
        "x": 230,
        "y": 560,
        "wires": [
            [
                "238a404850626bc6"
            ],
            [],
            []
        ]
    },
    {
        "id": "1297bbb74d04aeae",
        "type": "debug",
        "z": "5a4b47febf53ae59",
        "name": "Resultado Final",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 560,
        "wires": []
    },
    {
        "id": "890167617624f1e7",
        "type": "function",
        "z": "5a4b47febf53ae59",
        "name": "Calcular nivel, volumen, Q, ETA",
        "func": "// Retrieve container configuration\nconst container = global.get(\"container\");\nif (!container || !container.calibration_table || !container.height) {\n  node.error(\"Incomplete or missing container configuration\");\n  return null;\n}\n\nconst calibrationTable = container.calibration_table;\nconst maxHeight = container.height;\nconst maxVolume = calibrationTable[calibrationTable.length - 1].volume;\n\n// Get operation mode: 'load' (default) or 'discharge'\nconst operationMode = flow.get(\"operation_mode\") || \"load\";\n\n// Read or set reference height (distance from sensor to bottom of the container)\nlet sensorToBottom = flow.get(\"sensor_to_bottom\");\nconst distance = msg.payload.distance_cm;\nconst temperature = msg.payload.temperature;\nconst timestamp = Date.now();\n\nif (sensorToBottom === null || sensorToBottom === undefined) {\n  sensorToBottom = distance;\n  flow.set(\"sensor_to_bottom\", sensorToBottom);\n  node.warn(`Reference height saved: ${sensorToBottom} cm`);\n}\n\n// Calculate current liquid level\nlet level = sensorToBottom - distance;\nlet adjustedLevel = Math.max(0, Math.min(level, maxHeight)); // Clamp between 0 and container height\n\n// Linear interpolation for volume based on calibration table\nfunction interpolate(table, h) {\n  for (let i = 0; i < table.length - 1; i++) {\n    let a = table[i];\n    let b = table[i + 1];\n    if (h >= a.height && h <= b.height) {\n      let ratio = (h - a.height) / (b.height - a.height);\n      return a.volume + ratio * (b.volume - a.volume);\n    }\n  }\n  if (h <= table[0].height) return table[0].volume;\n  if (h >= table[table.length - 1].height)\n    return table[table.length - 1].volume;\n  return 0;\n}\n\n// Apply temperature compensation\nconst beta = 0.000214;\nconst referenceTemp = 20;\nconst rawVolume = interpolate(calibrationTable, adjustedLevel);\nlet adjustedVolume = rawVolume * (1 + beta * (temperature - referenceTemp));\nadjustedVolume = Math.max(0, Math.min(adjustedVolume, maxVolume)); // Clamp between 0 and max volume\n\n// Calculate flow rate and ETA\nconst previous = context.get(\"previous\") || {};\nconst deltaTime = (timestamp - (previous.timestamp || timestamp)) / 1000;\nconst deltaVolume = adjustedVolume - (previous.volume || adjustedVolume);\nconst flowRate = deltaTime > 0 ? deltaVolume / deltaTime : 0;\n\nlet ETA = 0;\nif (Math.abs(flowRate) > 0.001) {\n  if (operationMode === \"load\" && flowRate > 0) {\n    ETA = (maxVolume - adjustedVolume) / flowRate;\n  } else if (operationMode === \"discharge\" && flowRate < 0) {\n    ETA = adjustedVolume / Math.abs(flowRate);\n  }\n}\n\n// Save current state for next calculation\ncontext.set(\"previous\", { timestamp, volume: adjustedVolume });\n\n// Output message\nmsg.payload = {\n  container_id: container.id,\n  level_cm: adjustedLevel.toFixed(2),\n  temperature_C: temperature,\n  volume_L: adjustedVolume.toFixed(2),\n  flow_rate_Lps: flowRate.toFixed(3),\n  ETA_seconds: ETA.toFixed(1),\n  timestamp: msg.payload.timestamp,\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 560,
        "wires": [
            [
                "1297bbb74d04aeae"
            ]
        ]
    },
    {
        "id": "238a404850626bc6",
        "type": "json",
        "z": "5a4b47febf53ae59",
        "name": "Parsear JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 520,
        "y": 560,
        "wires": [
            [
                "890167617624f1e7"
            ]
        ]
    },
    {
        "id": "11c2cf4c449f4eb4",
        "type": "inject",
        "z": "f8bcc2348cc2da98",
        "name": "Cargar JSON",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 80,
        "wires": [
            [
                "64a7d90838022226"
            ]
        ]
    },
    {
        "id": "64a7d90838022226",
        "type": "file in",
        "z": "f8bcc2348cc2da98",
        "name": "Leer containers.json",
        "filename": "/home/simonll4/python/containers.json",
        "filenameType": "str",
        "format": "utf8",
        "sendError": true,
        "encoding": "none",
        "allProps": false,
        "x": 440,
        "y": 80,
        "wires": [
            [
                "456a9ed61f3c3a14"
            ]
        ]
    },
    {
        "id": "456a9ed61f3c3a14",
        "type": "json",
        "z": "f8bcc2348cc2da98",
        "name": "Parsear JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 680,
        "y": 80,
        "wires": [
            [
                "969621d97c16058d"
            ]
        ]
    },
    {
        "id": "969621d97c16058d",
        "type": "function",
        "z": "f8bcc2348cc2da98",
        "name": "Guardar en global y activar flujo",
        "func": "const container = msg.payload[0];\nglobal.set(\"container\", container);\nreturn { payload: msg.payload };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 80,
        "wires": [
            [
                "c0f13619ce7126fd"
            ]
        ]
    },
    {
        "id": "c0f13619ce7126fd",
        "type": "link out",
        "z": "f8bcc2348cc2da98",
        "name": "Activar flujo sensor",
        "mode": "link",
        "links": [
            "f687ee84718579e1"
        ],
        "x": 1135,
        "y": 80,
        "wires": []
    },
    {
        "id": "f687ee84718579e1",
        "type": "link in",
        "z": "f8bcc2348cc2da98",
        "name": "Sensor - Entrada activación",
        "links": [
            "c0f13619ce7126fd"
        ],
        "x": 125,
        "y": 340,
        "wires": [
            [
                "f2f1d942faad82ed"
            ]
        ]
    },
    {
        "id": "01e15de8c789a156",
        "type": "exec",
        "z": "f8bcc2348cc2da98",
        "command": "/home/simonll4/python/stop_sensor.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Terminar script del sensor",
        "x": 350,
        "y": 520,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "0d123e21a7578521",
        "type": "inject",
        "z": "f8bcc2348cc2da98",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 520,
        "wires": [
            [
                "01e15de8c789a156"
            ]
        ]
    },
    {
        "id": "f2f1d942faad82ed",
        "type": "subflow:e095f4b5827799a6",
        "z": "f8bcc2348cc2da98",
        "name": "",
        "x": 310,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "2b58bc7e2f25cb67",
        "type": "exec",
        "z": "f8bcc2348cc2da98",
        "command": "/home/simonll4/python/.venv/bin/python /home/simonll4/python/main.py",
        "addpay": "payload",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Ejecutar sensor HC-SR04",
        "x": 210,
        "y": 180,
        "wires": [
            [
                "4846e21d4fad7f58"
            ],
            [],
            []
        ]
    },
    {
        "id": "4846e21d4fad7f58",
        "type": "json",
        "z": "f8bcc2348cc2da98",
        "name": "Parsear JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 480,
        "y": 180,
        "wires": [
            [
                "3c82f783dd10c074"
            ]
        ]
    },
    {
        "id": "3c82f783dd10c074",
        "type": "function",
        "z": "f8bcc2348cc2da98",
        "name": "Calcular nivel, volumen, Q, ETA",
        "func": "const container = global.get(\"container\");\nif (!container || !container.calibration_table || !container.height) {\n  node.error(\"Datos del recipiente incompletos o no definidos\");\n  return null;\n}\n\nconst tabla = container.calibration_table;\nconst volumenMax = tabla[tabla.length - 1].volume;\n\n// Leer o definir altura de referencia (sensor al fondo)\nlet alturaSensorFondo = flow.get(\"altura_sensor_fondo\");\nconst distancia = msg.payload.distance_cm;\nconst T = msg.payload.temperature;\nconst ts = Date.now();\n\nif (alturaSensorFondo === null || alturaSensorFondo === undefined) {\n  // Guardar la primera distancia como referencia\n  alturaSensorFondo = distancia;\n  flow.set(\"altura_sensor_fondo\", alturaSensorFondo);\n  node.warn(`Altura de referencia guardada: ${alturaSensorFondo} cm`);\n}\n\n// Calcular altura del líquido (nivel actual)\nconst nivel = alturaSensorFondo - distancia;\nconst nivelAjustado = Math.max(0, nivel);\n\n// Interpolación lineal para obtener volumen\nfunction interpolar(tabla, h) {\n  for (let i = 0; i < tabla.length - 1; i++) {\n    let a = tabla[i];\n    let b = tabla[i + 1];\n    if (h >= a.height && h <= b.height) {\n      let f = (h - a.height) / (b.height - a.height);\n      return a.volume + f * (b.volume - a.volume);\n    }\n  }\n  if (h <= tabla[0].height) return tabla[0].volume;\n  if (h >= tabla[tabla.length - 1].height)\n    return tabla[tabla.length - 1].volume;\n  return 0;\n}\n\n// Volumen corregido por temperatura\nconst beta = 0.000214;\nconst tRef = 20;\nconst V0 = interpolar(tabla, nivelAjustado);\nlet Vadj = V0 * (1 + beta * (T - tRef));\nVadj = Math.max(0, Math.min(Vadj, volumenMax));\n\n// Calcular caudal y ETA\nconst prev = context.get(\"prev\") || {};\nconst deltaT = (ts - (prev.ts || ts)) / 1000;\nconst deltaV = Vadj - (prev.V || Vadj);\nconst Q = deltaT > 0 ? deltaV / deltaT : 0;\n\nlet ETA = 0;\nif (Math.abs(Q) > 0.001) {\n  ETA = Q > 0 ? (volumenMax - Vadj) / Q : Vadj / Math.abs(Q);\n}\n\ncontext.set(\"prev\", { ts: ts, V: Vadj });\n\n// Salida final\nmsg.payload = {\n  id: container.id,\n  nivel_cm: nivelAjustado.toFixed(2),\n  temperatura_c: T,\n  volumen_L: Vadj.toFixed(2),\n  caudal_Lps: Q.toFixed(3),\n  ETA_segundos: ETA.toFixed(1),\n  timestamp: msg.payload.timestamp,\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            [
                "c87cbe7e3dc90e5f"
            ]
        ]
    },
    {
        "id": "c87cbe7e3dc90e5f",
        "type": "debug",
        "z": "f8bcc2348cc2da98",
        "name": "Resultado Final",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 180,
        "wires": []
    }
]